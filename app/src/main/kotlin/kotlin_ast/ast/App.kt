/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package kotlin_ast.ast

// AST Parsing
// JSON Serialization for AST
import kotlinx.ast.common.*
import kotlinx.ast.common.AstSource.File
import kotlinx.ast.common.ast.Ast
import kotlinx.ast.common.ast.DefaultAstNode
import kotlinx.ast.common.klass.KlassDeclaration
import kotlinx.ast.grammar.kotlin.common.summary
import kotlinx.ast.grammar.kotlin.target.antlr.kotlin.KotlinGrammarAntlrKotlinParser
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.serializer

@Serializable data class ParameterTypeMapping(val paramName: String, val paramType: String)

@Serializable
data class FunctionTypeMapping(val funcRetType: String, val funcParams: List<ParameterTypeMapping>)

@Serializable
data class ClassTypeMapping(
        var className: String,
        /*
            constructor_params : {
                param_name,
                param_type
            }
        */
        var classConstructor: List<ParameterTypeMapping>,
        /*
            func_name : {
                function_return_type,
                function_params : {
                    param_name,
                    param_type
                }
            }
        */
        var classMethods: MutableMap<String, FunctionTypeMapping>
)

@Serializable
data class ProjectTypeMapping(var projectClasses: MutableMap<String, ClassTypeMapping>)

fun ParseParams(method: KlassDeclaration): List<ParameterTypeMapping> {

    var output_list: List<ParameterTypeMapping> = listOf()
    method.children.forEach { paramNode: Ast ->
        paramNode.takeIf { predicate -> predicate is KlassDeclaration }?.let { p ->
            val param_name = (p as KlassDeclaration).identifier?.identifier ?: "N/A"
            var param_ast_str = (p as KlassDeclaration).printString()
            val param_type = param_ast_str.substringAfter(param_name + " ").substringBefore(")")

            output_list = output_list.plus(ParameterTypeMapping(param_name, param_type))
        }
    }

    return output_list
}

fun ParseClassMethods(child: Ast): MutableMap<String, FunctionTypeMapping> {

    var output_map: MutableMap<String, FunctionTypeMapping> = mutableMapOf()
    // Classes with method have classBody nodes
    child.takeIf { predicate -> predicate.description.equals("classBody") }?.let { classBodyNode ->
        val classBody = classBodyNode as DefaultAstNode
        classBody.children.forEach { method: Ast ->
            method.takeIf { predicate -> predicate is KlassDeclaration }?.let { classMethodNode ->
                val method_kl_dec = classMethodNode as KlassDeclaration
                if (method_kl_dec.keyword.equals("fun")) {
                    val methodName = method_kl_dec.identifier?.identifier ?: "N/A"
                    val methodParams = ParseParams(method_kl_dec)
                    var methodReturnType = "Void"
                    if (method_kl_dec.type.size > 0) {
                        var method_str = method_kl_dec.printString()
                        methodReturnType =
                                method_str.substringAfter(methodName + " ").substringBefore(")")
                    }
                    // println("" + methodName + "(" + methodParams + ") : " + methodReturnType)
                    output_map.put(methodName, FunctionTypeMapping(methodReturnType, methodParams))
                }
            }
        }
    }

    return output_map
}

fun main(args: Array<String>) {

    if (args.size != 1) {
        println("Usage: ./gradlew run --args=\"<path_to_kotlin_file>\"")
        return
    }
    var output: ProjectTypeMapping = ProjectTypeMapping(mutableMapOf())
    var source: File = AstSource.File(args.get(0))

    val kotlinFile = KotlinGrammarAntlrKotlinParser.parseKotlinFile(source)
    kotlinFile
            .summary(attachRawAst = false)
            .onSuccess { astList ->
                astList.forEach { e ->
                    // Take Classes
                    e.takeIf { predicate -> predicate is KlassDeclaration }?.let { classAstNode ->
                        val classNode = classAstNode as KlassDeclaration
                        val className = classNode.identifier?.identifier ?: "N/A"

                        var node_constructor_params: List<ParameterTypeMapping> = listOf()
                        var node_methods: MutableMap<String, FunctionTypeMapping> = mutableMapOf()
                        // Take Methods
                        classNode.children.forEach { child: Ast ->
                            // Data class have KlassDeclarations with no classBody node
                            child.takeIf { predicate -> predicate is KlassDeclaration }?.let {
                                val constructor_kl_dec = child as KlassDeclaration
                                node_constructor_params = ParseParams(constructor_kl_dec)
                            }

                            node_methods = ParseClassMethods(child)
                        }

                        output.projectClasses.put(
                                className,
                                ClassTypeMapping(className, node_constructor_params, node_methods)
                        )
                    }
                }
            }
            .onFailure { errors -> errors.forEach(::println) }

    println(Json.encodeToString(ProjectTypeMapping.serializer(), output))
}
