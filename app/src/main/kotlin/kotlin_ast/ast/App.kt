/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package kotlin_ast.ast

// AST Parsing
// JSON Serialization for AST
import kotlinx.ast.common.*
import kotlinx.ast.common.ast.Ast
import kotlinx.ast.common.ast.DefaultAstNode
import kotlinx.ast.common.klass.KlassDeclaration
import kotlinx.ast.common.klass.identifierName
import kotlinx.ast.grammar.kotlin.common.summary
import kotlinx.ast.grammar.kotlin.common.summary.Import
import kotlinx.ast.grammar.kotlin.common.summary.PackageHeader
import kotlinx.ast.grammar.kotlin.target.antlr.kotlin.KotlinGrammarAntlrKotlinParser
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.net.URL
import java.net.URLClassLoader
import java.nio.file.Path
import java.util.*
import java.util.jar.JarFile
import kotlin.collections.ArrayList
import java.io.File

@Serializable data class ParameterTypeMapping(val paramName: String, val paramType: String)

@Serializable
data class FunctionTypeMapping(
        val funcName: String,
        val funcRetType: String,
        val funcParams: List<ParameterTypeMapping>
)

@Serializable
data class ClassTypeMapping(
        var className: String,
        /*
            constructor_params : {
                param_name,
                param_type
            }
        */
        var classConstructor: List<ParameterTypeMapping>,
        /*
            func_name : {
                function_return_type,
                function_params : {
                    param_name,
                    param_type
                }
            }
        */
        var classMethods: List<FunctionTypeMapping>
)

@Serializable
data class ProjectTypeMapping(
    var projectClasses: MutableMap<String, ClassTypeMapping>,
    var packageName : String,
    var imports : MutableMap<String, String>,
    var successfulParse : Boolean,
    var errorMessages : ArrayList<String>
)

val basicTypesList = listOf(
    "Boolean",
    "Byte",
    "Short",
    "Int",
    "Long",
    "Float",
    "Double",
    "Char",
    "String",
    "Boolean?",
    "Byte?",
    "Short?",
    "Int?",
    "Long?",
    "Float?",
    "Double?",
    "Char?",
    "Any",
    "Any?",
    "Unit",
    "Nothing",
    "Annotation",
    "Array",
    "BooleanArray",
    "ByteArray",
    "CharArray",
    "CharSequence",
    "Comparable",
    "Comparator",
    "DeepRecursiveFunction",
    "DeepRecursiveScope",
    "DeprecationLevel",
    "DoubleArray",
    "Enum",
    "FloatArray",
    "Function",
    "IntArray",
    "KotlinVersion",
    "Lazy",
    "LazyThreadSafetyMode",
    "LongArray",
    "Number",
    "Pair",
    "Result",
    "String",
    "Throwable",
    "Triple",
    "UByte",
    "UByteArray",
    "UInt",
    "UIntArray",
    "ULong",
    "ULongArray",
    "UShort",
    "UShortArray"
)


var PROJECT_ALREADY_BUILT = false
var PROJECT_PATH = ""
var JAR_PATH = ""
fun ParseParams(method: KlassDeclaration, out : ProjectTypeMapping): List<ParameterTypeMapping> {

    var output_list: List<ParameterTypeMapping> = listOf()
    method.children.forEach { paramNode: Ast ->
        paramNode.takeIf { predicate -> predicate is KlassDeclaration }?.let { p ->
            val param_name = (p as KlassDeclaration).identifier?.identifier ?: "N/A"

            var param_ast_str = p.printString()
            val param_type = param_ast_str.substringAfter(param_name + " ").substringBefore(")")

//              Check if param type is a basic type or has already been defined
            if (basicTypesList.contains(param_type) || out.projectClasses.contains(param_type)) {
                output_list = output_list.plus(ParameterTypeMapping(param_name, param_type))
            } else if (out.imports.contains(param_type)) {
//              Parameter type is defined somewhere else in an import
                if (!PROJECT_ALREADY_BUILT) {
                    JAR_PATH = buildTemporaryProject()
                    PROJECT_ALREADY_BUILT = true
                }

                val jarFile = JarFile(JAR_PATH)

                val urls: Array<URL> = arrayOf<URL>(URL("jar:file:$JAR_PATH!/"))
                val cl = URLClassLoader.newInstance(urls)

                val c = cl.loadClass(out.imports[param_type])

                var newExternalClassParams = listOf<ParameterTypeMapping>()
                var unparsableClass = false
                for (a in c.declaredFields) {
                    if (a.name == "Companion") {
                        continue
                    }

                    val kotlinTypeConversion = a.type.name.replace("java.lang.", "")

                    val capitalizedType = kotlinTypeConversion.replaceFirstChar {
                        if (it.isLowerCase())
                            it.titlecase(Locale.getDefault()) else it.toString()
                    }

                    if( !basicTypesList.contains(capitalizedType)) {
                        unparsableClass = true
                        break
                    }

                    newExternalClassParams = newExternalClassParams.plus(ParameterTypeMapping(a.name, capitalizedType))
                }

                if (unparsableClass) {
                    out.successfulParse = false
                    out.errorMessages.add("Error: ${param_type} has not been declared in this file " +
                            "and could not be parsed succesfully.\n" +
                            "If this class has been declared in another library a serialized string field is recommended instead!")
                    jarFile.close()
                    cl.close()
                    return output_list
                }
                val newExternalParsedClass = ClassTypeMapping(param_type, newExternalClassParams, listOf())
                out.projectClasses[param_type] = newExternalParsedClass
//                val newParsedClass = ClassTypeMapping()
                output_list = output_list.plus(ParameterTypeMapping(param_name, param_type))
                out.errorMessages.add("Warning: ${param_type} has not been declared in this file " +
                        "and therefore is treated as an external import.\n" +
                        "If this class has been declared in another library there is no guarantee " +
                        "that the parsing was successful.\n" +
                        "A serialized string is recommended instead!")
                jarFile.close()
                cl.close()
            }
            else {
                out.successfulParse = false
                out.errorMessages.add("Error: ${param_type} could not be found in list of imports and " +
                        "is not one of the Kotlin basic types: ${basicTypesList}\n" +
                        "Possible solutions:\n" +
                        "1. Check if you are importing ${param_type} using star projection (*) and if so" +
                        "use a fully qualified name instead\n" +
                        "2. If above step does not solve your problem declare ${param_type} in the same file as the class you want to deploy")
            }

        }
    }

    return output_list
}

fun ParseClassMethods(child: Ast, out: ProjectTypeMapping): List<FunctionTypeMapping> {

    var output: List<FunctionTypeMapping> = listOf()
    // Classes with method have classBody nodes
    child.takeIf { predicate -> predicate.description.equals("classBody") }?.let { classBodyNode ->
        val classBody = classBodyNode as DefaultAstNode
        classBody.children.forEach { method: Ast ->
            method.takeIf { predicate -> predicate is KlassDeclaration }?.let { classMethodNode ->
                val method_kl_dec = classMethodNode as KlassDeclaration
                if (method_kl_dec.keyword.equals("fun")) {
                    val methodName = method_kl_dec.identifier?.identifier ?: "N/A"
                    val methodParams = ParseParams(method_kl_dec, out)
                    var methodReturnType = "Void"
                    if (method_kl_dec.type.size > 0) {
                        var method_str = method_kl_dec.printString()
                        methodReturnType =
                                method_str.substringAfter(methodName + " ").substringBefore(")")
                    }
                    // println("" + methodName + "(" + methodParams + ") : " + methodReturnType)
                    output = output.plus(FunctionTypeMapping(methodName, methodReturnType, methodParams))
                }
            }
        }
    }

    return output
}

//Build project and return path of .jar file
fun buildTemporaryProject() : String {
    val os = System.getProperty("os.name").lowercase()
    val extension = if (os.startsWith("win")) ".bat" else ""
    val separator = if (os.startsWith("win")) "\\" else "/"
    val gradlewScript = "${separator}gradlew${extension}"
    val args = listOf(".${gradlewScript}", "-q", "--rerun-tasks", "fatJar")
    val process = ProcessBuilder()
    process.inheritIO()
    process.command(args)
    process.directory(java.io.File(PROJECT_PATH))
    process.start().waitFor()

    return Path.of(PROJECT_PATH, "app", "build", "libs", "app-standalone.jar").toString()
}
fun main(args: Array<String>) {
    if (args.size != 1) {
        println("Usage: java -jar \"<path_to_kotlin_file>\"")
        return
    }

    val path = args[0]
    PROJECT_PATH = System.getProperty("user.dir")


    var output: ProjectTypeMapping = ProjectTypeMapping(mutableMapOf(), "NOT YET PARSED", mutableMapOf(), true, arrayListOf())
    var source = AstSource.File(path)
    val kotlinFile = KotlinGrammarAntlrKotlinParser.parseKotlinFile(source)
    kotlinFile
        .summary(attachRawAst = false)
        .onSuccess { astList ->
            astList.forEach { e ->
                // Get Package Name
                e.takeIf { predicate -> predicate is PackageHeader }?.let {packageHeaderNode ->
                    val headerNode = packageHeaderNode as PackageHeader
                    output.packageName = headerNode.identifier?.identifierName().toString()
                }
                // Build import list
                e.takeIf { predicate -> predicate is DefaultAstNode && predicate.description.equals("importList")  }?.let { importListNode ->
                    val importNode = importListNode as DefaultAstNode
                    for (import in importListNode.children as List<Import>) {
                        var qualifiedImport = ""
                        for (identifier in import.identifier) {

                            if (import.identifier.indexOf(identifier) == import.identifier.size - 1 && !import.starProjection) {
                                qualifiedImport += identifier.identifier
                                output.imports[identifier.identifier] = qualifiedImport
                            } else {
                                qualifiedImport += identifier.identifier + "."
                            }
                        }
                    }
                }
                // Take Classes
                e.takeIf { predicate -> predicate is KlassDeclaration }?.let { classAstNode ->
                    val classNode = classAstNode as KlassDeclaration
                    val className = classNode.identifier?.identifier ?: "N/A"

                    if (classNode.keyword == "class")
                    {
                        var node_constructor_params: List<ParameterTypeMapping> = listOf()
                        var node_methods: List<FunctionTypeMapping> = listOf()
                        // Take Methods
                        classNode.children.forEach { child: Ast ->
                            // Data class have KlassDeclarations with no classBody node
                            child.takeIf { predicate -> predicate is KlassDeclaration }?.let {
                                val constructor_kl_dec = child as KlassDeclaration
                                node_constructor_params = ParseParams(constructor_kl_dec, output)
                            }

                            node_methods = ParseClassMethods(child, output)
                        }


                        output.projectClasses.put(
                            className,
                            ClassTypeMapping(className, node_constructor_params, node_methods)
                        )
                    }
                }
            }
        }
        .onFailure { errors -> errors.forEach(::println) }

    val prettyJson = Json { // this returns the JsonBuilder
        prettyPrint = true
        // optional: specify indent
        prettyPrintIndent = " "
    }

    var buildDir = File(Path.of(PROJECT_PATH, "app", "build").toString())
    try {
        buildDir.deleteRecursively()
    } catch (e : Exception)
    {
        println(e)
    }

    println(prettyJson.encodeToString(ProjectTypeMapping.serializer(), output))
}

